#include <stdio.h>

/*

内存对齐规则：
1. 基本数据类型：变量的内存地址必须是自身类型占用字节数的整数倍
   - int（4字节）：地址能被4整除
   - long long（8字节）：地址能被8整除
   - double（8字节）：地址能被8整除
   - char（1字节）：地址能被1整除（无对齐限制）


2. 结构体内存对齐：
   - 遵循基本类型的对齐规则
   - 对齐会补空白字节，但不改变原数据类型的实际大小
   - 结构体总大小必须是其内部最大数据类型字节数的整数倍
   
   
   心得：小的数据类型写在上面，节约空间
*/

// 示例1：
struct Num1 
{
    double a;  // 8字节，地址0-7（满足double对齐：0是8的整数倍）
    char b;    // 1字节，地址8（满足char对齐：8是1的整数倍）
    char d;    // 1字节，地址9（满足char对齐：9是1的整数倍） 10 11 为填补的空白字节
    int c;     // 4字节，地址12  13  14  15    总共16个字节满足最大类型字节倍数
};

// 示例2：优化内存的struct Num（小类型在前）
struct Num2 
{
    char b;    // 1字节，地址0
    char d;    // 1字节，地址1  
    int c;     // 4字节，地址4    2、3补空白字节
    double a;  // 8字节，地址8   空白字节：9 10 11 12 13 14 15 总共16个满足double字节的倍数
};

int main() {
    // 计算结构体大小
    printf("struct Num1的大小：%zu 字节\n", sizeof(struct Num1));  // 输出16
    printf("struct Num2的大小：%zu 字节\n", sizeof(struct Num2));  // 输出16（此例大小相同，复杂结构体优化效果更明显）

    return 0;
}